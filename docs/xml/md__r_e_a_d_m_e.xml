<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="md__r_e_a_d_m_e" kind="page">
    <compoundname>md_README</compoundname>
    <title>ResearchTrack1-assignment2</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This is the second assignment for the Research Track 1 exam for the Robotics Engineering Master&apos;s degree at the University of Genoa.</para>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md1">
<title>Simulator</title>
<para>The assignment takes place in Gazebo, a 3D ROS simulator. The Rviz tool is also used to provide a model of the simulator robot, including sensors, to help the user debug the robot application.</para>
<para>To run the environment, namely, the windows mentioned above Gazebo and Rviz, complete the following procedure (If you do not have already installed ROS on your computer, you can download and install the Noetic version used in this assignment at <ulink url="https://wiki.ros.org/noetic/Installation">https://wiki.ros.org/noetic/Installation</ulink>).</para>
<para>Steps:<itemizedlist>
<listitem><para>open at least two terminals.</para>
</listitem><listitem><para>in the first one, move into your ROS workspace and run the ROS master with the command <computeroutput>roscore</computeroutput>.</para>
</listitem><listitem><para>move to the second terminal and choose where to clone the repository</para>
</listitem><listitem><para>clone this repository with the command <computeroutput>git clone _url_</computeroutput>.</para>
</listitem><listitem><para>move into the directory</para>
</listitem><listitem><para>run the command <computeroutput>roslaunch assignment_2_2023 assignment1.launch</computeroutput> to start the simulation. At this point the simulator has started, the program is running and a mobile robot is spawned in the center of the playground.</para>
</listitem></itemizedlist>
</para>
<para>N.B. If the scripts are not found, go to the <computeroutput>scripts</computeroutput> folder and run the command <computeroutput>chmod +x *.py</computeroutput>. Then try again to run <computeroutput>roslaunch assignment_2_2023 assignment1.launch</computeroutput>.</para>
<para>It is important to notice (this topic is also better explained later) that the launch file <computeroutput>assignment1.launch</computeroutput>, not only runs the environment but also all the nodes of the assignment. By knowing that, to run just a single node the command <computeroutput>rosrun assignment_2_2023 _NodeName.py_</computeroutput> must be used.</para>
<para>The playground is represented by a squared arena in which the robot can move. Besides, some walls around and inside the playground obstruct the robot&apos;s motion.</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md2">
<title>Already implemented nodes</title>
<para>Some nodes were already implemented by the Professor of the course. These nodes aim to plan the motion of the robot.</para>
<para>Node <computeroutput>wall_follow_service.py</computeroutput> is used to let the robot follow a wall, for instance, to circumnavigate it. This node also processes data to detect obstacles and avoid them: if an obstacle is detected on the front, the node makes the robot rotate until there are no obstacles perceived. The same behaviour is implemented for obstacles on the right and the left.</para>
<para>Node <computeroutput>go_to_point_service_service.py</computeroutput> implements a finite state machine that controls whether the robot behaves correctly and lets it move towards a specified point. It also checks if and when the robot successfully reaches the goal.</para>
<para>Node <computeroutput>bug_as.py</computeroutput> is an action server used to decide the robot&apos;s behaviour according to a function <computeroutput>change_state</computeroutput>, responsible for switching the robot states. This function lets activate or deactivate specific behaviour such as <computeroutput>go_to_point</computeroutput> or <computeroutput>wall_following</computeroutput>. Besides, it imports messages and services, also from the other nodes, to facilitate communication between different components of the simulation system. These include messages for laser scan data, odometry information, twist commands for velocity control, and services for switching between navigation modes. Callback functions are implemented to process data, updating the robot&apos;s position and orientation. The <computeroutput>planning</computeroutput> function is used as a callback for the action server, implementing the robot&apos;s goal-planning behaviour. It considers obstacles in the environment.</para>
<para>Besides, a launch file <computeroutput>assignment1.launch</computeroutput> to run the whole simulation, both scripts and environment, is provided.</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md3">
<title>The assignment</title>
<para>The assignment requires handling long-running tasks: until now, when the robot is moving the user cannot do anything. The nodes that must be implemented are:<itemizedlist>
<listitem><para>an action client, allowing the user to set a target point or to cancel it (this node also uses the feedback/status of the action server to know when the target has been reached); this node also publishes robot position and velocity as a custom message.</para>
</listitem><listitem><para>a service node that, when called, returns the coordinates of the last target sent by the user.</para>
</listitem><listitem><para>a service node that subscribes to the robot&apos;s position and velocity and implements a server to retrieve the distance of the robot from the target and the robot&apos;s average speed. To conclude, a launch file to start the whole simulation must be implemented. It also must include a parameter to select the size of the averaging window of the last node.</para>
</listitem></itemizedlist>
</para>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md4">
<title>set_target_client.py</title>
<para><computeroutput>set_target_client.py</computeroutput> is the action client that satisfies the first request. It consists of different functions. Besides, this node is run, by the launch file, in a separate terminal, allowing the user to directly access the set-target interface.</para>
<sect3 id="md__r_e_a_d_m_e_1autotoc_md5">
<title>set_client_parameters</title>
<para>This function implements an action client, which also provides a user interface, running on a separate terminal, to let the user choose from the terminal either to:<itemizedlist>
<listitem><para>set a new target point that the robot must reach.</para>
</listitem><listitem><para>cancel the goal previously chosen.</para>
</listitem></itemizedlist>
</para>
<para>Firstly, the action client is activated and waits for the server. Once the server is running too, the goal position is extracted from <computeroutput>assignment_2_2023.msg.PlanningGoal()</computeroutput>; The type of the goal is specified by the <computeroutput>Planning.action</computeroutput> action file, which, indeed, defines the types of the goal that the action client sends to the action servers and the result and feedback that the action server sends back to the client.</para>
<para>If the user chooses to set a new goal, the target values, both x and y positions, are taken from the keyboard and the script checks whether they are float or not; if not the user can insert them again. Then the values are stored in such <computeroutput>input_x</computeroutput> and <computeroutput>input_y</computeroutput> variables and the ros parameters <computeroutput>des_pos_x</computeroutput> and <computeroutput>des_pos_y</computeroutput> are updated too, by using <lsquo/>rospy.set_param(<rsquo/>/des_pos_x&apos;, input_x)<computeroutput>and</computeroutput>rospy.set_param(&apos;/des_pos_y&apos;, input_y)`. In conclusion, the goal is sent to the server.</para>
<para>On the other hand, if the user chooses to cancel the goal, some singular situations must be handled. If the goal has never been entered or it has already been reached, it does not make sense to cancel it. To avoid this kind of scenario, two methods were implemented:<itemizedlist>
<listitem><para>the global variable <computeroutput>first_start</computeroutput> is used to check if the target has ever been set; if not it cannot be cancelled.</para>
</listitem><listitem><para>the status of the goal is checked: if it is not active, namely that the status is either &quot;succeded&quot; or &quot;preempted&quot;, the goal cannot be cancelled. Both checks provide the user with a brief explanation by printing why the goal cannot be cancelled. In all the other scenarios, the goal is correctly removed by using the command <computeroutput>client.cancel_goal()</computeroutput> and suddenly the robot stops.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md__r_e_a_d_m_e_1autotoc_md6">
<title>publisher_node</title>
<para>The <computeroutput>publisher_node</computeroutput> function is used to create and publish a custom message containing the actual position (x,y) and velocity (linear, angular) of the robot. This function represents the callback of a subscriber, which takes the required information subscribing to the topic <computeroutput>odom</computeroutput>.</para>
</sect3>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md7">
<title>last_target_service.py</title>
<para><computeroutput>last_target_service.py</computeroutput> is a node implementing a service that, when called, returns the values of the last target sent by the user. To make it feasible, a srv file <computeroutput>Last_target.srv</computeroutput> is created in the so-called directory; it contains the expected service response type. The last target values are extracted from the ros parameters updated from the <computeroutput>set_target_client,py</computeroutput> and returned as response from the service. If the service is called before the user sets a target, the response gives the default values (<computeroutput>/des_pos_x = 0.0</computeroutput> and <computeroutput>des_pos_y = 1.0</computeroutput>) chosen in the launch file <computeroutput>assignment1.launch</computeroutput>.</para>
<para>Furthermore, this service is run by the launch file; to call it and get the last target sent by the user run the command <computeroutput>rosservice call /last_target</computeroutput> on the terminal.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md8">
<title>info_service.py</title>
<para><computeroutput>info_service,py</computeroutput> is a node implementing a service that, when called, returns the distance from the goal and the average velocity of the robot. To make it feasible, a srv file <computeroutput>info_service.srv</computeroutput> is created in the so-called directory; it contains the expected service response type. A subscriber is implemented and its callback takes the target position from the ros parameters and the actual one from the custom message sent by the <computeroutput>set_target_client.py</computeroutput>. The distance is computed as the Euclidean distance by using the Python built-in function <computeroutput>math.dist(des_coordinates, actual coordinates)</computeroutput> by importing <computeroutput>math</computeroutput> library. The velocity values are extracted by the custom message too, they are collected in a list of dimension <computeroutput>window_size</computeroutput> with a default value of 10 (that can be modified in the launch file). Then the average velocity is computed as <computeroutput>average_vel_x = sum(vel_data) / min(len(vel_data), velocity_window_size)</computeroutput>. These values compose the response of the service.</para>
<para>As for <computeroutput>last_target_service.py</computeroutput>, <computeroutput>info_service.py</computeroutput> is run by the launch file and the service can be called by using the command <computeroutput>rosservice call /info_service</computeroutput> on the terminal.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md9">
<title>assignment1.launch</title>
<para><computeroutput>assignment1.launch</computeroutput> is the launch file that provides the possibility of running the whole simulation, including both the scripts and the environment, by using just one command: <computeroutput>roslaunch assignment_2_2023 assignment1.launch</computeroutput>.</para>
<para>In the launch file:<itemizedlist>
<listitem><para>the ros parameters <computeroutput>/des_pos_x</computeroutput>, <computeroutput>/des_pos_y</computeroutput> and <computeroutput>/window_size</computeroutput> are defined and can be easily modified.</para>
</listitem><listitem><para>Gazebo and Rviz tools are launched.</para>
</listitem><listitem><para>All the scripts previously mentioned are launched too.</para>
</listitem><listitem><para>The <computeroutput>set_target_client.py</computeroutput> is launched in a different terminal, to allow the user to easily set the target, by adding <computeroutput>launch-prefix=&quot;lxterminal -e&quot;</computeroutput> to the respective node tag.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md10">
<title>Flowchart</title>
<para><ulink url="https://mermaid.live/edit#pako:eNptVcGO2jAQ_RXLl16AksACpVKrZWF76mmrVmqyQiYxxGpiR7bDLgX-vWM7EBvKAcJ45s2bN-PJEWcip3iO-_1-yjXTJZ0jRfVaE7mDn6xklOtBfUi59Uj5thRvWUGkRj8Wn1OO4KOazU6SukAVYdyZzOcxuQNC3SmHvIhxphkpmaL5qzuiPHcP7vsR9ftfUB35_xaR4XGT-i5V6jFZJCTTTHDUsmAKZaQsaY4Iz9EbYVqhrZAeO11Q1MYoKvdUogbUKRGzweZkT7Ql7WWJEiMA2ja8zQY5lAdaE0kqqqlULce18Q8xYkO1ISXaCfiCXJr8oYApRYWkUB6GB_wxp2pdC7V-7x4P6I3pAuV0S5pSoz0pG6qCXE_HpaDKltoZGygXFAlapYWRFxHHqbODYnCUEZ5Ro8zXs4--TAxziw6UmASxgRazwhAFna8bHdBZRklT56CqS2M6ExYceK-OvwqWFVahoAAbrDTRjQoJraLkR0Gvutoe0lfvPA7OudD_8VkfqLJu7SS54h2HG3VMAcYsxQaglBa1CpC2pFQ0Sr6ZKID5oNEGnGkl9jdz9Zy8wK1w8KB3MJavrU93I9wkuovisVlYQ-xbYmN68ixPJuoErT6hpdcXi7WM_E5Z07NH0eULpsuCOX1OaNUdBD2xcSuHZ8W9O4stzlXfAmaHlJKS_AB6Ud52AO7y6aqp31MLEoQbpQMEW_Al9sKxYxv0_lLnbRvv6-8KtSvNX2rXpVU3G9h9BZVrsw29RREl4KMyyWrba-g6LLbLUmqCMesuFczInpYiY_rgDVodJxkUq4E7QT_holZUKbLzp7oeJRcmbpJbF1Qd7CoB5DUg-xER1FubAapH1yJxD1dUwkrL4X1yNOYUA1pFUzyHx3YTpTjlZ3AljRYvB57huVWwh93lXzIC2lRXK82ZFvK7e0nZd1UP14T_FgJ8tGyo_YvnR_yO59FwNpgOZ6N4Molmo2j0EPfwAc9n40E8ng6n0WwcDacPk_jcw38twHAweZiO4-FsOpqMo0-T6ez8D_exG6c"><image type="html" name="pako:eNptVcGO2jAQ_RXLl16AksACpVKrZWF76mmrVmqyQiYxxGpiR7bDLgX-vWM7EBvKAcJ45s2bN-PJEWcip3iO-_1-yjXTJZ0jRfVaE7mDn6xklOtBfUi59Uj5thRvWUGkRj8Wn1OO4KOazU6SukAVYdyZzOcxuQNC3SmHvIhxphkpmaL5qzuiPHcP7vsR9ftfUB35_xaR4XGT-i5V6jFZJCTTTHDUsmAKZaQsaY4Iz9EbYVqhrZAeO11Q1MYoKvdUogbUKRGzweZkT7Ql7WWJEiMA2ja8zQY5lAdaE0kqqqlULce18Q8xYkO1ISXaCfiCXJr8oYApRYWkUB6GB_wxp2pdC7V-7x4P6I3pAuV0S5pSoz0pG6qCXE_HpaDKltoZGygXFAlapYWRFxHHqbODYnCUEZ5Ro8zXs4--TAxziw6UmASxgRazwhAFna8bHdBZRklT56CqS2M6ExYceK-OvwqWFVahoAAbrDTRjQoJraLkR0Gvutoe0lfvPA7OudD_8VkfqLJu7SS54h2HG3VMAcYsxQaglBa1CpC2pFQ0Sr6ZKID5oNEGnGkl9jdz9Zy8wK1w8KB3MJavrU93I9wkuovisVlYQ-xbYmN68ixPJuoErT6hpdcXi7WM_E5Z07NH0eULpsuCOX1OaNUdBD2xcSuHZ8W9O4stzlXfAmaHlJKS_AB6Ud52AO7y6aqp31MLEoQbpQMEW_Al9sKxYxv0_lLnbRvv6-8KtSvNX2rXpVU3G9h9BZVrsw29RREl4KMyyWrba-g6LLbLUmqCMesuFczInpYiY_rgDVodJxkUq4E7QT_holZUKbLzp7oeJRcmbpJbF1Qd7CoB5DUg-xER1FubAapH1yJxD1dUwkrL4X1yNOYUA1pFUzyHx3YTpTjlZ3AljRYvB57huVWwh93lXzIC2lRXK82ZFvK7e0nZd1UP14T_FgJ8tGyo_YvnR_yO59FwNpgOZ6N4Molmo2j0EPfwAc9n40E8ng6n0WwcDacPk_jcw38twHAweZiO4-FsOpqMo0-T6ez8D_exG6c?type=png" inline="yes"></image>
</ulink></para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md11">
<title>Possible improvements</title>
<para>This project has several possible improvements.</para>
<para>First of all, as it is possible to notice, the robot moves quite slowly; its speed can be increased to achieve a faster and smoother simulation. However, the speed increase must be feasible also in the real world, namely, it is required to not exceed physical boundaries.</para>
<para>The provided user interface can be modified to become more user-friendly. It can be redesigned to be more attractive, for instance by presenting a more detailed and easy-to-use menu for the user. Besides, it is possible to build commands to use services directly from the same terminal where the desired position is entered. This would make it easier for the user to interact with the robot and the simulation. Until now just one terminal for the desired position is opened, while the services must be called separately on another terminal.</para>
<para>Furthermore, the desired goal, inserted by the user, should be graphically added to the playground. A goal marker would clarify where the goal is located and make it possible to visually check how the simulation is proceeding.</para>
<para>In order to make the simulation even more user-friendly, it should be possible to choose the goal directly from the playground, by clicking on it. In addition, non-performable goals should not be eligible, such as points that do not belong to the playground or points belonging to the obstacles. Besides, the possibility of choosing multiple goals to create a path that the robot must follow can be implemented too.</para>
<para>When encountering obstacles, the robot &quot;autonomously&quot; chooses the direction along which follows the wall. To improve performance, the chosen direction should be the one that belongs to the shortest path to the goal.</para>
<para>To conclude, although several improvements are possible, the project fully accomplishes the required tasks. </para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
